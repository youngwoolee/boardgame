package com.project.boardgame.service;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.project.boardgame.service.dto.GeneratedGameDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.openai.OpenAiChatOptions;
import org.springframework.stereotype.Service;

@Service
@Slf4j
@RequiredArgsConstructor
public class AiService {

    private final ChatClient openAiChatClient;
    private final ObjectMapper objectMapper; // Spring Boot automatically provides this bean

    // A simple record to hold the data generated by the AI
    private record AiGeneratedContent(String description, List<String> genres, List<String> systems) {}


    public GeneratedGameDto getGameData(String gameName) {
        // 1. Scrape factual data from BoardGameGeek's embedded JSON
        GeneratedGameDto scrapedDto = scrapeBoardGameDetailsFromApi(gameName);
        if (scrapedDto == null) {
            log.error("Failed to scrape initial data for game: {}", gameName);
            return null;
        }

        // 2. Use AI to generate descriptive content
        AiGeneratedContent aiContent = generateDescriptiveContent(gameName);
        if (aiContent == null) {
            log.error("Failed to generate AI content for game: {}", gameName);
            return null;
        }

        // 3. Merge AI content into the scraped DTO
        scrapedDto.setDescription(aiContent.description());
        scrapedDto.setGenres(aiContent.genres());
        scrapedDto.setSystems(aiContent.systems());

        return scrapedDto;
    }

    private AiGeneratedContent generateDescriptiveContent(String gameName) {
//        String systemContent = "당신은 보드게임 전문가 AI입니다. 사용자가 보드게임 이름을 제공하면, 해당 게임의 상세 정보를 JSON 형식으로 출력해야 합니다. 응답은 반드시 한국어로 작성하세요.";
//
//        String userContent = "보드게임 이름 '" + gameName + "'의 상세 정보를 분석하여 아래 JSON 형식에 맞춰 응답하세요.\n" +
//                "description: 1~5문장 요약. minPlayers: 최소 인원(숫자). maxPlayers: 최대 인원(숫자). age: 권장 연령('10'처럼 숫자만). time: 플레이 시간('30'처럼 숫자만). " +
//                "genres: ['전략', '파티', '가족게임', '추리', '협력', '경쟁', '심리전', '퍼즐', '카드게임', '어린이', '교육', '블러핑', '협상', '팀플레이'] 중에서 2~3개 선택. " +
//                "systems: ['셋컬렉션', '정체은닉', '트릭테이킹', '카드드래프트', '타일배치', '노선연결', '주사위굴리기', '자원관리', '협력플레이', '액션포인트', '핸드관리', '주사위조합', '타일조합', '질문추론', '블러핑눈치'] 중에서 2~3개 선택.";



        String systemContent = "You are a board game expert AI. Your task is to provide descriptive information about a board game in JSON format, in Korean.";
        String userContent = "For the board game named '" + gameName + "', provide the following information in the specified JSON format.\n" +
                "description: A summary of 1-5 sentences. " +
                "genres: Choose 2-3 from this list: ['전략', '파티', '가족게임', '추리', '협력', '경쟁', '심리전', '퍼즐', '카드게임', '어린이', '교육', '블러핑', '협상', '팀플레이']. " +
                "systems: Choose 2-3 from this list: ['셋컬렉션', '정체은닉', '트릭테이킹', '카드드래프트', '타일배치', '노선연결', '주사위굴리기', '자원관리', '협력플레이', '액션포인트', '핸드관리', '주사위조합', '타일조합', '질문추론', '블러핑눈치'].";

        SystemMessage systemMessage = new SystemMessage(systemContent);
        UserMessage userMessage = new UserMessage(userContent);
        OpenAiChatOptions options = OpenAiChatOptions.builder()
                .model("gpt-4.1-mini")
                .temperature(0.1)
                .build();
        Prompt prompt = new Prompt(List.of(systemMessage, userMessage), options);

        try {
            return openAiChatClient.prompt(prompt).call().entity(AiGeneratedContent.class);
        } catch (Exception e) {
            log.error("Error calling AI to generate descriptive content for '{}': {}", gameName, e.getMessage());
            return null;
        }
    }


    private GeneratedGameDto scrapeBoardGameDetailsFromApi(String gameName) {
        try {
            // 1. Search for the game to find its specific page URL
            String searchUrl = "https://boardgamegeek.com/search/boardgame?q=" + URLEncoder.encode(gameName, StandardCharsets.UTF_8);
            Document searchDoc = Jsoup.connect(searchUrl).userAgent("Mozilla/5.0").get();

            Element firstLink = searchDoc.selectFirst("a.primary");
            if (firstLink == null) {
                log.warn("No search result found for game: {}", gameName);
                return null;
            }
            String detailPageUrl = "https://boardgamegeek.com" + firstLink.attr("href");

            // 2. Connect to the game's detail page
            Document detailDoc = Jsoup.connect(detailPageUrl).userAgent("Mozilla/5.0").get();

            // 3. Find the script tag containing the GEEK.geekitemPreload data
            Elements scriptElements = detailDoc.getElementsByTag("script");
            String scriptData = null;
            for (Element element : scriptElements) {
                if (element.data().contains("GEEK.geekitemPreload")) {
                    scriptData = element.data();
                    break;
                }
            }

            if (scriptData == null) {
                log.error("Could not find GEEK.geekitemPreload script tag for {}", gameName);
                return null;
            }

            // 4. Use a more robust regex to extract the entire JSON object, handling newlines.
            Pattern pattern = Pattern.compile("GEEK\\.geekitemPreload = (\\{.*?\\});", Pattern.DOTALL);
            Matcher matcher = pattern.matcher(scriptData);
            if (!matcher.find()) {
                log.error("Could not extract JSON from script for {}", gameName);
                return null;
            }
            String jsonData = matcher.group(1);

            // 5. Parse the JSON and map to DTO
            JsonNode root = objectMapper.readTree(jsonData);
            JsonNode item = root.path("item");

            GeneratedGameDto dto = new GeneratedGameDto();
            dto.setMinPlayers(item.path("minplayers").asInt());
            dto.setMaxPlayers(item.path("maxplayers").asInt());
            dto.setAge(item.path("minage").asInt());
            dto.setImageUrl(item.path("imageurl").asText());

            dto.setMinPlayTime(item.path("minplaytime").asInt());
            dto.setMaxPlayTime(item.path("maxplaytime").asInt());
            double rawWeight = item.path("stats").path("avgweight").asDouble();
            double roundedWeight = Math.round(rawWeight * 10.0) / 10.0;
            dto.setWeight(roundedWeight);

            // Best player count can be a range, so we'll take the first "best" value.
            JsonNode bestPoll = item.path("polls").path("userplayers").path("best");
            if (bestPoll.isArray() && !bestPoll.isEmpty()) {
                dto.setBestPlayers(bestPoll.get(0).path("min").asInt());
            }

            return dto;

        } catch (Exception e) {
            log.error("Failed to scrape details for '{}': {}", gameName, e.getMessage());
            return null;
        }
    }
}
